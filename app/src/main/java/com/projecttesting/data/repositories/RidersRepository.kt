package com.projecttesting.data.repositories

import com.projecttesting.data.daos.RidersDao
import com.projecttesting.data.models.Rider
import com.projecttesting.data.services.RidersService
import com.projecttesting.data.sources.RidersSource
import com.projecttesting.network.NetworkHandler
import com.projecttesting.network.RequestCallback
import timber.log.Timber
import javax.inject.Inject
import javax.inject.Singleton


/**
 * singleton is maintained by Dagger
 *
 * @Inject tells Dagger that this class can be injected
 * Dagger automatically calls this constructor, if an instance of this class is requested.
 *
 * @param ridersService  remote data source; generated by retrofit
 *
 */
@Singleton
class RidersRepository @Inject constructor(
    private val ridersService: RidersService,
    private val ridersDao: RidersDao
) : RidersSource {

    override suspend fun getRider(): Rider? {

        Timber.w("TODO: Hardcoded rider id")
        val riderId = 1

        // check if rider exists in database
        return loadRiderFromLocalDataSource(riderId) ?:
        // doesn't exist make an api call
        loadRiderFromRemoteDataSource(riderId)
    }

    private fun loadRiderFromLocalDataSource(riderId: Int): Rider? {
        return ridersDao.getRiderById(riderId)
    }

    private suspend fun loadRiderFromRemoteDataSource(riderId: Int): Rider? {

        var rider: Rider? = null

        NetworkHandler.request(ridersService.getRiderById(riderId), object : RequestCallback<Rider> {

            override fun onError(message: String?) {
                // TODO: handle error state
            }

            override fun onSuccess(data: Rider?) {
                // TODO: we could move this logic into a domain/[UseCase]
                data?.let {
                    rider = data
                    ridersDao.insertRider(data)
                }
            }

            override fun onLoading() {
                // TODO: handle loading state
            }
        })

        return rider

    }

    suspend fun updateRider(rider: Rider) {
        NetworkHandler.request(ridersService.updateRider(rider.id!!, rider), object : RequestCallback<Rider> {

            override fun onError(message: String?) {
                // TODO: handle error state
            }

            override fun onSuccess(data: Rider?) {
                data?.let {
                    ridersDao.updateRider(data)
                }
            }

            override fun onLoading() {
                // TODO: handle loading state
            }
        })
    }

}